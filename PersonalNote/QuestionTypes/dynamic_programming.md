# Dynamic Programming

## 이것이 코딩 테스트다 - 08

다이나믹 프로그래밍 = 한 번 계산한 문제는 다시 계산하지 않도록 하는 알고리즘

2가지 방식 = TopDown, BottomUp

대표적인 예시 = 피보나치 수열  
a_n+2 = f(a_n+1, a_n) = a_n+1 + a_n  
수학적 점화식을 프로그래밍으로 표현하려면 재귀 함수를 이용하면 간단하다.

피보나치 수열을 완전 탐색으로 풀면 TC 가 Theta(1.618...^N), O(2^N) 이다.  
O(2^N) 인 이유는 점화식을 보면 알 수 있듯이, f(N) 을 수행할 때 하위 함수 2개를 연산하기 때문이다 (2*2*2*... N번 반복).

다이나믹 프로그래밍을 사용할 수 있는 필요 조건

1. 큰 문제를 작은 문제로 나눌 수 있다.
2. 작은 문제에서 구한 정답은 그것을 포함하는 큰 문제에서도 동일하다.

다이나믹 프로그래밍 != DivideAndConquer  
Quick Sort 가 D&C 이다. 다른 이유는, 분할 정복은 부분 문제를 다시 풀지는 않는다.  
DP 는 한 번 해결했던 문제를 다시 해결해야한다. (이걸 해결하기 위해 memoization 을 사용한다).

DP 를 적용한 피보나치 수열 알고리즘의 TC 는 O(N) 이다. N 개의 부분 문제만 풀면 되기 때문이다.

- TopDown = 재귀 함수 이용 = 하향식
- BottomUp = 반복문 이용 = 상향식

보통 DP 테이블이라고 하는, Python 에서는 List 를 많이 사용한다.

하지만, 때에 따라서 dict 도 사용한다.  
수열 처럼 연속적이지 않은 경우에 유용하다.  
일부의 작은 문제에 대한 해답만 필요한 경우에 효과적이다.

DP 도, 3차원 리스트를 이용해야 하는 복잡한 난이도의 문제, 예를 들어 플로이드 워셜 알고리즘이 있다.

### DP 문제 접근법

- 특정 문제를 완전 탐색 알고리즘으로 접근했을 때, 시간이 매우 오래 걸리면 DP 적용할 수 있는지 확인
  - 부분 문제들의 중복 여부 확인
- 혹은 재귀 함수로 완전 탐색으로 일단 짠 후, 나중에 메모이제이션을 적용해보는 것도 좋다.
- 가능하면 List 를 사용해서 바텀업으로 짜는게 좋다 (function call stack overflow 때문에)
  - 하지만 이 경우 **sys.setrecursionlimit() 을 호출하여 재귀 제한을 완화할 수 있다!**

### Examples

```Python
d = [0] * 100

d[1] = 1
d[2] = 1
n = 99

for i in range(3, n + 1):
    d[i] = d[i - 1] + d[i - 2]
```

```Python
d = [0] * 100

def fibo(x):
    if x == 1 or x == 2:
        return 1
    if d[x] != 0:
        return d[x]
    d[x] = fibo(x - 1) + fibo(x - 2)
    return d[x]
```
